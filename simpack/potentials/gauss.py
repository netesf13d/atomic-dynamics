# -*- coding: utf-8 -*-
"""
Functions pertaining to the gaussian beam potential.
Potential expression, computation of force and potential, sampling.

The gaussian beam potential at position (x, y, z) has the form:
U(x, y, z) = - V0 / sqrt((1 + ((z-dz) / zRx)^2) * (1 + ((z+dz) / zRy)^2))
             * exp(-2 * x^2 / (wx^2 * (1 + ((z-dz) / zRx)^2)))
             * exp(-2 * y^2 / (wy^2 * (1 + ((z+dz) / zRy)^2)))
where:
    - V0 is the depth parameter, proportional to the laser intensity
    - (wx, wy) the waists along x and y
    - (zRx, zRy), the Rayleigh ranges along x and y
    - dz, the focus offset

Utility function is:
    - <_unpack_gbeam_params>, function to manage the parametrization
      of the gaussian beam potential
The potential and force functions are:
    - <gbeam_pot_np>, numpy evaluation of the gaussian beam potential
    - <gbeam_pot_sym>, sympy expression of the gaussian beam potential
    - <build_gbeam_pot>, build a function returning the potential
    - <build_gbeam_force>, build a function returning the force
    - <gbeam_local_params>, get the local parameter of the trap near
      its minimum
The sampling functions are:
    - <gbeam_sampling>, sample atomic positions and velocites in a gaussian
      beam potential with the rejection sampling method
    - <normal_gbeam_sampler>, build a sampler that returns samples at a
      given temperature under the harmonic approximation for the gaussian
      beam potential

The sampling system should be refactored as a class (as is done in numpy)
"""

import warnings

import numpy as np
import sympy as sym

from ..simutils import (
    unpack_param,
    build_potential,
    build_force,
    harmonic_sampling,
    rejection_sampling,
    recap_energy)
from ..config.physics import gauss_defaults, k_B, m_Rb87


rng = np.random.default_rng()

# =============================================================================
# Utility functions
# =============================================================================

def _unpack_gbeam_params(**kwargs):
    """
    Unpack the parameters of the gaussian potential provided as kwargs.
    
    Valid parameters are:
    - V0 : The amplitude of the potential, proportional to the total
        power (but not to the maximal intensity in general! Think about it).
        A positive V0 corresponds to an attractive potential.
    - waist : Waist(s) of the gaussian beam. Can be either a number w0 or
        a pair (wx, wy). This leads to returned values (w0, w0) or
        (wx, wy), respectively.
    -  z_R : Rayleigh range(s) of the gaussian beam. Can be either a
        number zR0 or a pair (zRx, zRy). This leads to returned values
        (zR0, zR0) or (zRx, zRy), respectively.
    -  dz : Focus offset of the x and y components.
    
    Unspecified parameters are set as default:
    - V0 = 1.77e-26 J
    - waist = 1.2e-6 m
    - z_R = 5.52e-6 m
    - dz = 0 m
    
    The expression of the gaussian potential is:
    U(x, y, z) = - V0 / sqrt((1 + ((z-dz) / zRx)^2) * (1 + ((z+dz) / zRy)^2))
                 * exp(-2 * x^2 / (wx^2 * (1 + ((z-dz) / zRx)^2)))
                 * exp(-2 * y^2 / (wy^2 * (1 + ((z+dz) / zRy)^2)))

    Parameters
    ----------
    **kwargs : Number or sequence
        Parameters of the gaussian beam. Valid parameters are:
        - V0 : Number, depth of the potential
        - waist : Number or sequence, waist(s) of the gaussian beam
        - z_R : Number or sequence, Rayleigh range(s) of the gaussian beam
        - dz : Number, focus offset of the x and y components
        Other parameters are ignored.

    Raises
    ------
    ValueError
        If dz > z_R (this gives the trap a weird shape).

    Returns
    -------
    V0, wx, wy, zRx, zRy, dz : Number
        The unpacked values of the trap parameters.

    """
    
    params = gauss_defaults | kwargs
    V0 = float(params['V0'])
    wx, wy = unpack_param(params['waist'])
    zRx, zRy = unpack_param(params['z_R'])
    dz = float(params['dz'])
    
    if abs(dz) >= zRx or abs(dz) >= zRy:
        raise ValueError(
            f"dz ({dz}) > zRx ({zRx}) or zRy ({zRy}), "
            "this would cause bad code behavior")
    
    return V0, wx, wy, zRx, zRy, dz


# =============================================================================
# Potential and forces
# =============================================================================

def gbeam_pot_np(x: np.ndarray,
                 y: np.ndarray,
                 z: np.ndarray,
                 **kwargs)-> np.ndarray:
    """
    Energy of an atom in the potential generated by a gaussian tweezer
    parametrized by:
        - V0, the depth, proportional to the laser intensity
        - (wx, wy) the waists along x and y
        - (zRx, zRy), the Rayleigh ranges along x and y
        - dz, the focus offset
    
    The energy is - V0 * I(r, z) with I(r, z) the (quasi-)normalized
    intensity of the gaussian beam:
    
    I(x, y, z) = 1 / (wx_red(z) * wy_red(z)) 
                 * exp(-2 * x^2 / (wx * wx_red(z))^2)
                 * exp(-2 * y^2 / (wy * wy_red(z))^2)
    
    wx_red(z) = sqrt(1 + ((z-dz) / zRx)^2)
    wy_red(z) = sqrt(1 + ((z+dz) / zRy)^2)

    Parameters
    ----------
    x, y, z : 1D np.ndarray
        Positions at which the potential is evaluated.
    **kwargs : Number or sequence
        Parameters of the gaussian beam. Valid parameters are:
        - V0 : Number, depth of the potential
        - waist : Number or sequence, waist(s) of the gaussian beam
        - z_R : Number or sequence, Rayleigh range(s) of the gaussian beam
        - dz : Number, focus offset of the x and y components
        Missing parameters are set as defaults, other parameters are ignored.
        See <unpack_gbeam_params> for detailed info.

    Returns
    -------
    np.ndarray
        Trapping potential evaluated at positions (x, y, z).

    """
    V0, wx, wy, zRx, zRy, dz = _unpack_gbeam_params(**kwargs)
    
    red_wx2 = (1 + ((z-dz) / zRx)**2)
    red_wy2 = (1 + ((z+dz) / zRy)**2)
    
    ex = np.exp(-2 * x**2 / (wx**2 * red_wx2))
    ey = np.exp(-2 * y**2 / (wy**2 * red_wy2))
    
    return - V0 / np.sqrt(red_wx2 * red_wy2) * ex * ey


def gbeam_pot_sym(x, y, z,
                  **kwargs):
    """
    Sympy expression of the potential generated by a gaussian tweezer
    parametrized by:
        - V0, the depth, proportional to the laser intensity
        - (wx, wy) the waists along x and y
        - (zRx, zRy), the Rayleigh ranges along x and y
        - dz, the focus offset
    
    The expression of the potential is:
    U(x, y, z) = - V0 / sqrt((1 + ((z-dz) / zRx)^2) * (1 + ((z+dz) / zRy)^2))
                 * exp(-2 * x^2 / (wx^2 * (1 + ((z-dz) / zRx)^2)))
                 * exp(-2 * y^2 / (wy^2 * (1 + ((z+dz) / zRy)^2)))

    Parameters
    ----------
    x, y, z : sympy symbols
        The variables of the potential.
    **kwargs : Number or sequence
        Parameters of the gaussian beam. Valid parameters are:
        - V0 : Number, depth of the potential
        - waist : Number or sequence, waist(s) of the gaussian beam
        - z_R : Number or sequence, Rayleigh range(s) of the gaussian beam
        - dz : Number, focus offset of the x and y components
        Missing parameters are set as defaults, other parameters are ignored.
        See <unpack_gbeam_params> for detailed info.

    Returns
    -------
    sympy expression
        Expression of the trapping potential as a function of symbols
        x, y, z

    """
    V0, wx, wy, zRx, zRy, dz = _unpack_gbeam_params(**kwargs)
    
    red_wx2 = (1 + ((z-dz) / zRx)**2)
    red_wy2 = (1 + ((z+dz) / zRy)**2)
    
    ex = sym.exp(-2 * x**2 / (wx**2 * red_wx2))
    ey = sym.exp(-2 * y**2 / (wy**2 * red_wy2))
    
    return - V0 / sym.sqrt(red_wx2 * red_wy2) * ex * ey


def build_gbeam_pot(**kwargs)-> callable:
    """
    Wrapper function to compute a lambda function for numerical evaluation
    of the gaussian beam potential defined in <gbeam_pot_sym>.
    """
    return build_potential(lambda x, y, z: gbeam_pot_sym(x, y, z, **kwargs))


def build_gbeam_force(**kwargs)-> tuple[callable]:
    """
    Wrapper function to compute a lambda function for numerical evaluation
    of the gaussian beam potential defined in <gbeam_pot_sym>.
    """
    return build_force(lambda x, y, z: gbeam_pot_sym(x, y, z, **kwargs))


def gbeam_local_params(**kwargs):
    """
    From the gaussian trap parameters, compute the parameters that
    characterize the trap locally near its minimum:
    - zmin, position of the minimum of the trap
    - Vmax, the maximum depth, different in general from the trap depth
      parameter V0
    - omega_x, omega_y, omega_z, the effective trap frequencies associated
      to the curvature at the minimum

    Parameters
    ----------
    **kwargs : Number or sequence
        Parameters of the gaussian beam. Valid parameters are:
        - V0 : Number, depth of the potential
        - waist : Number or sequence, waist(s) of the gaussian beam
        - z_R : Number or sequence, Rayleigh range(s) of the gaussian beam
        - dz : Number, focus offset of the x and y components
        Missing parameters are set as defaults, other parameters are ignored.
        See <unpack_gbeam_params> for detailed info.

    """
    V0, wx, wy, zRx, zRy, dz = _unpack_gbeam_params(**kwargs)
    # Computation intermediates to get the position of the minimum
    a = (zRx**2 + zRy**2) / 2 - dz**2
    b = dz * (zRx**2 - zRy**2)
    alpha = (27/4*b + np.sqrt(27 * (b**2/8 + a**3)))**(1/3)
    # Position of the minimum
    zmin = a/alpha - alpha/3
    # Computation intermediates for the max potential and frequencies
    red_zx2 = ((zmin-dz) / zRx)**2
    red_zy2 = ((zmin+dz) / zRy)**2
    red_wx2 = 1 + red_zx2
    red_wy2 = 1 + red_zy2
    # Max potential and frequencies
    Vmax = V0 / np.sqrt(red_wx2 * red_wy2)
    omega_x = np.sqrt(4*Vmax / m_Rb87 / (wx**2 * red_wx2))
    omega_y = np.sqrt(4*Vmax / m_Rb87 / (wy**2 * red_wy2))
    omega_z = np.sqrt(Vmax / m_Rb87 *
        (-2*(zmin**2-dz**2) / ((zRx*zRy)**2 * red_wx2 * red_wy2)
         + (1 - 2*red_zx2) / (zRx * red_wx2)**2
         + (1 - 2*red_zy2) / (zRy * red_wy2)**2)
        )
    
    return zmin, Vmax, omega_x, omega_y, omega_z


# =============================================================================
# Sampling
# =============================================================================

class gbeam_sampler():
    # TODO
    # ccould be nice
    pass


def gbeam_sampling(nbSamples: int,
                   T: float,
                   **kwargs)-> np.ndarray:
    """
    Draw samples of position and velocity for atoms in the trap at
    temperature T. Positions are drawn with the rejection sampling
    method.
    
    Velocities are drawn from a normal distribution of variance
    k_B * T / m_Rb87.
    
    The rejection sampling method is implemented in function
    <simutils.rejection_sampling>.
    For this method to operate efficiently, the region actually explored
    by atoms at given temperature must be computed in order not to draw
    irrelevant positions.
    This is done by considering only positions (x, y, z) such that:
    exp(-V(x, y, z) / k_B*T) > threshold,
    with the potential V shifted such that V(x, y, z) <= 0 = V(0, 0, 0).
    The above condition is equivalent to:
    p(x, y, z)/p(0, 0, 0) > threshold,
    where p denotes the probability of finding an atom at (x, y, z)
    
    For low enough temperatures, the region above threshold is too small,
    in this case harmonic sampling is used instead.
    
    A final filtering of the samples is made to ensure that all the
    retained samples have negative energy (Ep + Ec), thus correspond
    to trapped atoms.
    
    Parameters
    ----------
    nbSamples : int
        Number of samples drawn for the simulation.
    T : float
        The Temperature in Kelvins.
    **kwargs : Number or sequence
        Parameters of the gaussian beam. Valid parameters are:
        - V0 : Number, depth of the potential
        - waist : Number or sequence, waist(s) of the gaussian beam
        - z_R : Number or sequence, Rayleigh range(s) of the gaussian beam
        - dz : Number, focus offset of the x and y components
        Missing parameters are set as defaults, other parameters are ignored.
        See <unpack_gbeam_params> for detailed info.

    Returns
    -------
    spl : 2D np.ndarray
        Atom samples as an array of shape (6, nbSamples). The format is :
            - samples[0, i], samples[1, i], samples[2, i] :
                x, y, z coordinates of atom i respectively
            - 6samples[3, i], samples[4, i], samples[5, i] :
                v_x, v_y, v_z components of atom i respectively

    """
    _, wx, wy, zRx, zRy, _ = _unpack_gbeam_params(**kwargs)
    zmin, Vmax, omega_x, omega_y, omega_z = gbeam_local_params(**kwargs)
    
    # The potential as a function of (x, y, z)
    pot = build_gbeam_pot(**kwargs)
    # Shift the potential so that it is always positive
    potential = lambda x, y, z: pot(x, y, z) + Vmax
    
    # Threshold to define the "region" of the trap explored by the atoms at
    # a given temperature
    threshold = np.log(1e3)
    
    # shape of the array defining the interior
    shx, shy, shz = (2**7, 2**7, 2**7)
    # size of the array in non-dimensionalized units
    szx, szy, szz = (2**3, 2**3, 2**4) # (waist, waist, rayleigh range)
    
    # Localization of the origin in array coordinates, not necessarily integer
    loc = ((shx-1)/2, (shy-1)/2, (shz-1)/2)
    # Scale of the array coordinates in waist units
    zR = max(zRx, zRy)
    scale = (wx*szx/shx, wy*szy/shy, zR*szz/shz)
    
    xx, yy, zz = np.mgrid[-(szx-1)*wx/2:(szx-1)*wx/2:shx*1j,
                          -(szy-1)*wy/2:(szy-1)*wy/2:shy*1j,
                          -(szz-1)*zR/2:(szz-1)*zR/2:shz*1j,]
    
    # Set the interior
    # The reason for the shift, np.roll, is explained in <rejection_sampling>
    beam = potential(xx, yy, zz)/(k_B*T) < threshold
    interior = beam + np.roll(beam, (-1, -1, -1), axis=(0, 1, 2))
    
    if not np.any(interior):
        warnings.warn(
            "Atoms are localized in an excessively small region of space. "
            "Switching to normal sampling...",
            UserWarning
            )
        spl = harmonic_sampling(nbSamples, T, omega_x, omega_y, omega_z)
        spl[2, :] += zmin # proper centering
        return spl
    
    # Check that the interior is not hitting the edges
    if (np.any(interior[0, :, :])
        or np.any(interior[:, 0, :])
        or np.any(interior[:, :, 0])):
        warnings.warn(
            "Gaussian beam sampling: The sampled space is too small to "
            "account for the whole distribution of positions at a "
            f"temperature of {T*1e6:.2} uK. Try cooling down your atoms.",
            UserWarning
            )
    
    # Initialize the container for the samples
    spl = np.empty((6, nbSamples), dtype=float)
    # std dev of velocity (v_x, v_y, v_z)
    sigma_v = np.full((3, 1), np.sqrt(k_B * T / m_Rb87), dtype=float)
    
    nbspl = 0 # number of accepted samples
    while nbspl < nbSamples:
        rspl = np.empty((6, 2*nbSamples), dtype=float)
        # Build a set of samples, of 2 times the desired size
        rspl[0:3, :] = rejection_sampling(
            2*nbSamples, T, potential, interior, loc, scale)
        rspl[3:6, :] = rng.normal(0, sigma_v, (3, 2*nbSamples))
        
        # Select the samples whose energy is negative
        (selectind,), p = recap_energy(rspl, pot, thr=0)
        nbind = selectind.size
        if nbind + nbspl >= nbSamples: # Enough samples
            spl[:, nbspl:nbSamples] = \
                rspl[:, selectind[0:nbSamples-nbspl]]
            nbspl = nbSamples
        else: # Not enough samples
            spl[:, nbspl:nbind + nbspl] = rspl[:, selectind]
            nbspl = nbind + nbspl
    
    return spl


def normal_gbeam_sampler(**kwargs)-> callable:
    """
    Build a function that return samples at given temperature in the 
    gaussian beam potential under the harmonic approximation.
    
    The distribution of positions is determined by the local parameters
    of the trapping potential: zmin, omega_x, omega_y, omega_z.
    The distribution of velocities has variance k_B * T / m_Rb87.
    
    Note that the vertical is set along y.

    Parameters
    ----------
    **kwargs : Number or sequence
        Parameters of the gaussian beam. Valid parameters are:
        - V0 : Number, depth of the potential
        - waist : Number or sequence, waist(s) of the gaussian beam
        - z_R : Number or sequence, Rayleigh range(s) of the gaussian beam
        - dz : Number, focus offset of the x and y components
        Missing parameters are set as defaults, other parameters are ignored.
        See <unpack_gbeam_params> for detailed info.

    Returns
    -------
    spler : callable
        function f: nbSamples, T -> samples
        The resulting samples are an array of shape (6, nbSamples).
            - samples[0, i], samples[1, i], samples[2, i] :
                x, y, z coordinates of atom i respectively
            - samples[3, i], samples[4, i], samples[5, i] :
                v_x, v_y, v_z components of atom i respectively

    """
    zmin, Vmax, omega_x, omega_y, omega_z = gbeam_local_params(**kwargs)
    
    mu = np.array([0, 0, zmin, 0, 0, 0], dtype=float).reshape((6, 1))
    ## vertical is along y !
    # standard deviations
    rsigma_v = np.sqrt(k_B / m_Rb87) # reduced std dev of velocity
    rsigma_x = rsigma_v / omega_x # reduced std dev of position along x
    rsigma_y = rsigma_v / omega_y # reduced std dev of position along y
    rsigma_z = rsigma_v / omega_z # std dev of position along z
    # std deviations of (x, y, z, vx, vy, vz) respectively
    rsigma = np.array([rsigma_x, rsigma_y, rsigma_z,
                       rsigma_v, rsigma_v, rsigma_v])
    rsigma = rsigma.reshape((6, 1))

    spler = lambda nbSamples, T: \
        rng.normal(mu, np.sqrt(T) * rsigma, (6, nbSamples))
    return spler


