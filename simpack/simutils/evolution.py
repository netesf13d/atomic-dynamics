# -*- coding: utf-8 -*-
"""
Functions related to the (classical) simulation of trapped atoms dynamics.
    - <evolution>, evolve a set of sampled positions and velocities in a
      force field
    - <run_simu>, evolve a set of sampled positions and velocities in a given
      sequence
    - <sim_traj>, simulate the trajectory of a set of sampled positions and
      velocities in a given sequence
    - <recap_energy>, compute the indices of recaptured samples and the
      recapture probability from the condition that the mechanical energy
      is negative
    - <recap_interior>, compute the indices of recaptured samples and the
      recapture probability from the condition that atomic positions are in
      a given region of space

TODO
- gendoc
"""

from typing import Callable

import numpy as np

from ..config.physics import g, m_Rb87


# =============================================================================
# Functions to compute the evolution
# =============================================================================

def evolution(spl: np.ndarray,
              dt: float,
              force: tuple[Callable, Callable, Callable] | None = None)-> None:
    """
    Evolve the sampled positions and velocities in the presence of a force
    field for a duration dt:
        x -> x + vx * dt
        y -> y + vy * dt - g/2 * dt^2
        z -> z + vz * dt
        vx -> vx + Fx * dt
        vy -> vy + Fy * dt - g * dt
        vz -> vz + Fz * dt
    
    The vertical is set to be along y, and the beam propagates along z.
    
    All operations are carried inplace (this means that the new values of
    position and velocity erase the p
    revious ones).
    
    Note that to ensure proper dynamics, y position is modified before
    the corresponding velocity vy.

    Parameters
    ----------
    spl : np.ndarray
        Atom samples as an array of shape (6, nbSamples). The format is :
            - spl[0, i], spl[1, i], spl[2, i] :
                x, y, z coordinates of atom i respectively
            - spl[3, i], spl[4, i], spl[5, i] :
                v_x, v_y, v_z components of atom i respectively
    dt : float
        The duration of the evolution.
    force : 3-tuple of callable
        The applied forces Fx(x, y, z), Fy(x, y, z), Fz(x, y, z).
        Fi(x, y, z) yields the force along axis i.
        It must take as arguments:
            x, y, z : 1D arrays
        It returns:
            Fi : 1D array, Fi[j] = Fi(x[j], y[j], z[j])

    """
    dg = g * dt # computation intermediate
    spl[0, :] += dt * spl[3, :]
    spl[1, :] += dt * spl[4, :] - dg * dt / 2
    spl[2, :] += dt * spl[5, :]
    # application of the forces
    if force is None:
        spl[4, :] -= dg
    else:
        ds = dt/m_Rb87 # computation intermediate
        spl[3, :] += force[0](spl[0, :], spl[1, :], spl[2, :]) * ds
        spl[4, :] += force[1](spl[0, :], spl[1, :], spl[2, :]) * ds - dg
        spl[5, :] += force[2](spl[0, :], spl[1, :], spl[2, :]) * ds


def run_simu(spl: np.ndarray,
             forces: tuple[tuple[Callable, Callable, Callable], ...],
             amps: tuple[Callable | float, ...],
             pos: tuple[Callable | float, ...],
             dt: float,
             t_tot: float)-> None:
    """
    Run a simulation of a given sequence.
    
    The samples are modified inplace to yield the positions and velocities
    at the end of the sequence.
    
    The sequence is specified as:
        - a set of n forces Fi (Fi_x, Fi_y, Fi_z)
        - a set of amplitudes Ai that are either constant or a function
          of the time. 
        - a set of offsets (xi, yi, zi) that are either constant or a
          function of the time
    At time t, the samples are subject to the forces:
        sum(Ai * Fi(x - xi, y - yi, z - zi), i=0..n)
    
    For instance, consider atoms in a gaussian tweezer with sinusoidal
    amplitude modulation. Then:
        - forces = ((Fx, Fy, Fz),) the force field generated by a single
          gaussian tweezer
        - amps = (1 + A*sin(t),) the sinusoidal modulation
        - pos = ((0, 0, 0),) zero offset since the tweezers don't move
    
    An other example is the case of atom rearrangement, with an initial
    static tweezer loaded with atoms, a static target tweezer and a
    rearrangement tweezer which amplitude and position varies in time.
    Then:
        - forces = ((Fx, Fy, Fz),) * 3: 3 gaussian tweezers
        - amps = (1, A(t), 1): tweezers 0 and 2 are static, rearrangement
          tweezer ramps up and down to tranfer atoms
        - pos = ((0, 0, 0), (x(t), y(t), z(t)), (x1, y1, z1))
          target tweezer 2 is offset wrt loaded tweezer 0, rearrangement
          tweezer displaces atoms between them.

    Parameters
    ----------
    spl : np.ndarray
        Atom samples as an array of shape (6, nbSamples). The format is :
            - spl[0, i], spl[1, i], spl[2, i] :
                x, y, z coordinates of atom i respectively
            - spl[3, i], spl[4, i], spl[5, i] :
                v_x, v_y, v_z components of atom i respectively
    forces : tuple[tuple[Callable, Callable, Callable], ...]
        The set of forces to which the atoms are subject. The format is:
        ((F0_x, F0_y, F0_z), (F1_x, F1_y, F1_z), ...)
        where Fi_x, Fi_y, Fi_z are callable, Fi_j(x, y, z) giving the
        j-th component of force i at position (x, y, z).
    amps : tuple[Callable | float, ...]
        The set of amplitudes which scale the forces. The format is:
        (A0, A1, ...) where Ai is either a callable or a number.
        The forces applied to atom samples are rescaled by the Ai's :
        F = sum(Ai * Fi).
        It is recommended to keep the physics in the forces, setting the
        Ai's as non-dimensional amplification factors.
    pos : tuple[Callable | float, ...]
        The set of positions which offset the forces in space. The format
        is:
        ((x0, y0, z0), (x1, y1, z1), ...) where the xi's are either
        callable or numbers. The forces applied are offset by the
        positions:
        F(x, y, z) = sum(Fi(x - xi, y - yi, z - zi))
    dt : float
        The duration of the evolution.
    t_tot : float
        Total duration of the sequence.

    Raises
    ------
    ValueError
        If the number of forces, amplitudes and positions specified do not
        match.

    Returns
    -------
    None.

    """
    # check that forces, amps, pos have same length
    n = len(forces)
    if (l := len(amps)) != n or (m := len(pos)) != n:
        raise ValueError(
            f"mismatch between number of forces {n}, number of amplitudes, "
            f"{l}, and number of positions, {m}")
    
    # Subdivise sequence duration t_tot into atomic timesteps
    N = int(np.ceil(round(t_tot / dt, ndigits=5))) # nb of atomic timesteps
    times = np.linspace(0, N*dt, N, endpoint=False)
    steps = np.full(N, dt, dtype=float)
    try:
        steps[-1] = t_tot - (N-1)*dt
    except IndexError: # edge case T=0
        pass
    
    # Parse amplitudes to get their values at the various times
    A = np.empty((N, n), dtype=float)
    for i, x in enumerate(amps):
        if callable(x):
            A[:, i] = x(times)
        elif isinstance(x, (int, float)):
            A[:, i] = x
    # Parse positions to get their values at the various times
    r0 = np.empty((N, n, 3), dtype=float)
    for i, r in enumerate(pos):
        for j in range(3):
            if isinstance(r[j], callable):
                r0[:, i, j] = r[j](times)
            elif isinstance(r[j], (int, float)):
                r0[:, i, j] = r[j]
    
    for i in range(N):
        # Compute forces at i-th timestep
        Fx = lambda x, y, z: sum(
            A[i, k] * forces[k][0](x-r0[i, k, 0],
                                   y-r0[i, k, 1],
                                   z-r0[i, k, 2])
            for k in range(n)
            )
        Fy = lambda x, y, z: sum(
            A[i, k] * forces[k][1](x-r0[i, k, 0],
                                   y-r0[i, k, 1],
                                   z-r0[i, k, 2])
            for k in range(n)
            )
        Fz = lambda x, y, z: sum(
            A[i, k] * forces[k][2](x-r0[i, k, 0],
                                   y-r0[i, k, 1],
                                   z-r0[i, k, 2])
            for k in range(n)
            )
        # Evolution for a timestep dt
        evolution(spl, steps[i], (Fx, Fy, Fz))
        

def sim_traj(ispl: np.ndarray,
             forces: tuple[tuple[Callable, Callable, Callable], ...],
             amps: tuple[Callable | float, ...],
             pos: tuple[Callable | float, ...],
             dt: float,
             t_tot: float)-> tuple[np.ndarray, np.ndarray]:
    """
    Compute the trajectory of a set of atom samples in a given sequence.
    
    The evolving positions and velocities of the samples are given at each
    time step. Note that this generates a lot of data, hence this function
    should be used for a small number of samples.
    
    The sequence is specified as:
        - A set of n forces Fi (Fi_x, Fi_y, Fi_z)
        - A set of amplitudes Ai that are either constant or a function
          of the time. 
        - A set of offsets (xi, yi, zi) that are either constant or a
          function of the time
    At time t, the samples are subject to the forces:
        sum(Ai * Fi(x - xi, y - yi, z - zi), i=0..n)
    
    For instance, consider atoms in a gaussian tweezer with sinusoidal
    amplitude modulation. Then:
        - forces = ((Fx, Fy, Fz),) the force field generated by a single
          gaussian tweezer
        - amps = (1 + A*sin(t),) the sinusoidal modulation
        - pos = ((0, 0, 0),) zero offset since the tweezers don't move
    
    An other example is the case of atom rearrangement, with an initial
    static tweezer loaded with atoms, a static target tweezer and a
    rearrangement tweezer which amplitude and position varies in time.
    Then:
        - forces = ((Fx, Fy, Fz),) * 3: 3 gaussian tweezers
        - amps = (1, A(t), 1): tweezers 0 and 2 are static, rearrangement
          tweezer ramps up and down to tranfer atoms
        - pos = ((0, 0, 0), (x(t), y(t), z(t)), (x1, y1, z1))
          target tweezer 2 is offset wrt loaded tweezer 0, rearrangement
          tweezer displaces atoms between them.

    Parameters
    ----------
    ispl : np.ndarray
        Atom samples as an array of shape (6, nbSamples). The format is :
            - ispl[0, i], ispl[1, i], ispl[2, i] :
                x, y, z coordinates of atom i respectively
            - ispl[3, i], ispl[4, i], ispl[5, i] :
                v_x, v_y, v_z components of atom i respectively
    forces : tuple[tuple[Callable, Callable, Callable], ...]
        The set of forces to which the atoms are subject. The format is:
        ((F0_x, F0_y, F0_z), (F1_x, F1_y, F1_z), ...)
        where Fi_x, Fi_y, Fi_z are callable, Fi_j(x, y, z) giving the
        j-th component of force i at position (x, y, z).
    amps : tuple[Callable | float, ...]
        The set of amplitudes which scale the forces. The format is:
        (A0, A1, ...) where Ai is either a callable or a number.
        The forces applied to atom samples are rescaled by the Ai's :
        F = sum(Ai * Fi).
        It is recommended to keep the physics in the forces, setting the
        Ai's as non-dimensional amplification factors.
    pos : tuple[Callable | float, ...]
        The set of positions which offset the forces in space. The format
        is:
        ((x0, y0, z0), (x1, y1, z1), ...) where the xi's are either
        callable or numbers. The forces applied are offset by the
        positions:
        F(x, y, z) = sum(Fi(x - xi, y - yi, z - zi))
    dt : float
        The duration of the evolution.
    t_tot: float
        Total duration of the sequence.

    Raises
    ------
    ValueError
        If the number of forces, amplitudes and positions specified do not
        match.

    Returns
    -------
    times : 1D np.ndarray
        The timesteps at which the trajectory is sampled.
    traj_spl : 3D np.ndarray
        Atomic samples positions and velocity at each timestep.
        traj_spl[i, :, :] = trajectory samples at times[i]
        (same format as ispl)

    """
    # check that forces, amps, pos have same length
    n = len(forces); l = len(amps); m = len(pos)
    if l != n or m != n:
        raise ValueError(
            f"mismatch between number of forces {n}, number of amplitudes, "
            f"{l}, and number of positions, {m}")
    
    # Subdivise sequence duration t_tot into atomic timesteps
    N = int(np.ceil(round(t_tot / dt, ndigits=5))) # nb of atomic timesteps
    steps = np.full(N, dt, dtype=float)
    try:
        steps[-1] = t_tot - (N-1)*dt
    except IndexError: # edge case T=0
        pass
    
    times = np.linspace(0, N*dt, N+1, endpoint=True)
    times[-1] = t_tot
    traj_spl = np.empty((N+1, 6, ispl.shape[1]), dtype=float)
    traj_spl[0, :, :] = np.copy(ispl)
    
    # Parse amplitudes to get their values at the various times
    A = np.empty((N, n), dtype=float)
    for i, x in enumerate(amps):
        if callable(x):
            A[:, i] = x(times[:-1])
        elif isinstance(x, (int, float)):
            A[:, i] = x
    # Parse positions to get their values at the various times
    r0 = np.empty((N, n, 3), dtype=float)
    for i, r in enumerate(pos):
        for j in range(3):
            if callable(r[j]):
                r0[:, i, j] = r[j](times[:-1])
            elif isinstance(r[j], (int, float)):
                r0[:, i, j] = r[j]
    
    for i in range(N):
        traj_spl[i+1, :, :] = np.copy(traj_spl[i, :, :])
        # Compute forces at i-th timestep
        Fx = lambda x, y, z: sum(
            A[i, k] * forces[k][0](x-r0[i, k, 0],
                                   y-r0[i, k, 1],
                                   z-r0[i, k, 2])
            for k in range(n)
            )
        Fy = lambda x, y, z: sum(
            A[i, k] * forces[k][1](x-r0[i, k, 0],
                                   y-r0[i, k, 1],
                                   z-r0[i, k, 2])
            for k in range(n)
            )
        Fz = lambda x, y, z: sum(
            A[i, k] * forces[k][2](x-r0[i, k, 0],
                                   y-r0[i, k, 1],
                                   z-r0[i, k, 2])
            for k in range(n)
            )
        # Evolution for a timestep dt
        evolution(traj_spl[i+1, :, :], steps[i], (Fx, Fy, Fz))
    return times, traj_spl


def recap_energy(spl: np.ndarray,
                 potential: Callable,
                 thr: float = 0.)-> tuple[tuple[np.ndarray], float]:
    """
    Compute the recapture indices and recapture probability for a given
    sample of atomic positions and velocities. The recapture condition is
    that the mechanical energy must be inferior to a given threshold.
    
    Em = Ep + Ec < threshold, with
    Ep = potential(x, y, z)
    Ec = 1/2 * m_Rb87 * (v_x^2 + v_y^2 + v_z^2)
    
    This method is relevant when the potential has an unique minimum
    in the trapping region, as in the case of gaussian traps.

    Parameters
    ----------
    spl : np.ndarray
        Atom spl as an array of shape (6, nbSamples). The format is :
            - spl[0, i], spl[1, i], spl[2, i] :
                x, y, z coordinates of atom i respectively
            - spl[3, i], spl[4, i], spl[5, i] :
                vx, vy, vz velocity components of atom i respectively
    potential : Callable
        Function V(x, y, z) yielding the potential energy.
        It must take as arguments:
            x, y, z : 1D arrays
        It returns:
            V : 1D array, V[i] = V(x[i], y[i], z[i])
    thr : float
        Energy threshold to set the recapture condition:
        the atom is recaptured if E < thr

    Returns
    -------
    rindices : 1-tuple of 1D array ([i0, i1, i2, ...],)
          Indices of the samples that are recaptured
    precap : float
        The recapture probability estimated from the samples. The number
        of samples with energy < 0 over the number of samples.

    """
    # kinetic energy
    Ec = m_Rb87/2 * (spl[3, :]**2 + spl[4, :]**2 + spl[5, :]**2)
    # potential energy
    Ep = potential(spl[0, :], spl[1, :], spl[2, :])
    
    return np.nonzero(rspl := (Ec + Ep < thr)), np.sum(rspl)/spl.shape[1]


def recap_interior(spl: np.ndarray,
                   interior: np.ndarray,
                   loc: tuple[int, int, int],
                   pxsize: tuple[float, float, float]
                   )-> tuple[tuple[np.ndarray], float]:
    """
    Compute the recapture indices and recapture probability for a given
    sample of atomic positions and velocities. The recapture condition is
    that the position must be in a region defining the interior of the
    trap.
    
    This method is relevant when the potential does not have an unique
    minimum, as in the case of BoB traps.

    Parameters
    ----------
    spl : np.ndarray
        Atom spl as an array of shape (6, nbSamples). The format is :
            - spl[0, i], spl[1, i], spl[2, i] :
                x, y, z coordinates of atom i respectively
            - spl[3, i], spl[4, i], spl[5, i] :
                vx, vy, vz velocity components of atom i respectively
    interior : np.ndarray of bool
        Defines the "interior" of the trap, that is, the trapping
        region to determine whether the atoms are trapped.
        More specifically, if interior[i, j, k] is True, then the
        positions x, y, z = i + r, j + s, k + t for r, s, t in [0, 1)
        are assumed to be in the trapping region.
    loc : tuple (i0, j0, k0)
        The position of the physical origin (position (0, 0, 0)) in the 
        array defining the interior, expressed in array coordinates.
        The conversion from array indices to physical positions is:
        index = position / scale + loc
        It is not necessarily an integer.
    pxsize : tuple (dx, dy, dz)
        The voxel dimensions of the array defining the interior, in m.
        The conversion from physical positions to array indices is:
        index = position / pxsize + loc

    Returns
    -------
    rindices : 1-tuple of 1D array ([i0, i1, i2, ...],)
          Indices of the samples that are recaptured
    precap : float
        The recapture probability estimated from the samples.

    """
    ijk = ((spl[0, :] / pxsize[0] + loc[0]).astype(int),
           (spl[1, :] / pxsize[1] + loc[1]).astype(int),
           (spl[2, :] / pxsize[2] + loc[2]).astype(int))
    return np.nonzero(rspl := interior[ijk]), np.sum(rspl)/spl.shape[1]


